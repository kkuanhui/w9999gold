import { useEffect, useRef, useState } from "react"
import ContentEditable from "react-contenteditable"
import { renderToString } from 'react-dom/server'
import { setCursorAtPosition } from "./gptTest"

const EditFrame = (props) => {
  const {
    activeItem, 
    onRemoveAct, 
    onChangeMode,
    onSetNotEditing,
    onSetIsEditing,
    isEditing,
    isEditable
  } = props

  // ref -----
  const component = useRef(null)

  // state -----
  const [isDisabled, setIsDisabled] = useState(true);
  const [cursorPos, setCursorPos] = useState([0, 0]);
  
  // life cycle -----
  useEffect(() => {
    if(isDisabled === false){
      setCursorAtPosition(cursorPos[0], cursorPos[1])
    }
  }, [isDisabled, cursorPos])

  return(
    <ContentEditable 
      id="editable"
      style={{
        position: "absolute",
        top: "0px",
        left: "0px",
        userSelect: 'none'
      }} 
      innerRef={component}
      html={renderToString(
        activeItem.children.map((pObj, key) => {
          return <Paragraph pObj={pObj} key={key}></Paragraph>
        })
      )} 
      disabled={isDisabled} // use true to disable editing
      tagName='div' // Use a custom HTML tag (uses a div by default)
      onClick={(e) => {
        if(isDisabled){
          setIsDisabled(false);
          setCursorPos([e.clientX, e.clientY])
          // after state isDisabled changed simulate click event
        }
      }}
      onBlur={() => {
        setIsDisabled(true)
        onSetNotEditing();
      }}
    >
    </ContentEditable>
  )
}

const Paragraph = (props) => {
  const {pObj} = props
  return(
    <p>
      {pObj.children.map((spanObj, key) => {
        return <Span spanObj={spanObj} key={key}></Span>
      })}
    </p>
  )
}

const Span = (props) => {
  const {spanObj} = props
  const style = {
    fontSize: `${spanObj.fontSize}px`,
    fontFamily: spanObj.fontFamily,
    fontStyle: spanObj.italic ? "italic" : "normal",
    textDecoration: spanObj.underline ? "underline" : "none",
    fontWeight: spanObj.bold ? "bold" : "normal",
  };
  return <span style={style}>{spanObj.children}</span>;
};

// functions -----
const altering = (node, range, setting) => {
  const startEle = range.anchor.path;
  const endEle = range.focus.path;
  // traverse
  node.content.slice(startEle[0], endEle[0] + 1).forEach((p, key) => {
    if (key === 0) {
      // first paragraph
      const shift = splitOffsetPlace(
        p.children,
        range.anchor.path[1],
        range.anchor.offset
      );
      for (let i = range.anchor.path[1] + shift; i < p.children.length; i++) {
        p.children[i] = { ...p.children[i], ...setting };
      }
    } else if (key === endEle[0]) {
      // last paragraph
      splitOffsetPlace(p.children, range.focus.path[1], range.focus.offset);
      for (let i = 0; i < range.focus.path[1] + 1; i++) {
        p.children[i] = { ...p.children[i], ...setting };
      }
    } else {
      for (let i = 0; i < p.children.length; i++) {
        p.children[i] = { ...p.children[i], ...setting };
      }
    }
  });
};

// generated by ChatGPT
const coalescence = (arr) => {
  // refining in one paragraph
  const result = [];
  let currentObj = {};
  for (let i = 0; i < arr.length; i++) {
    const candidate = arr[i];
    if (i === 0) {
      // first one
      currentObj = { ...candidate }; // duplication
    } else if (
      // if properties don't match.
      candidate.dom !== currentObj.dom ||
      candidate.bold !== currentObj.bold ||
      candidate.italic !== currentObj.italic ||
      candidate.underline !== currentObj.underline
    ) {
      // push to result and start a new object
      result.push(currentObj);
      currentObj = { ...candidate };
    } else {
      // Properties match, combine children
      currentObj.children = (currentObj.children || "") + candidate.children;
    }
  }
  result.push(currentObj); // push the last object
  return result;
};

function splitOffsetPlace(arr, target, offset) {
  // direct change on input array
  if (arr[target].children.length !== offset) {
    // check if split is neccessary
    var b4Obj = { ...arr[target] }; // make copy
    b4Obj.children = b4Obj.children.slice(0, offset);
    arr[target].children = arr[target].children.slice(offset);
    arr.splice(target, 0, b4Obj);
    return 1;
  }
  return 0;
}

export default EditFrame;