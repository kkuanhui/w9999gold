import _ from "lodash";

export const processSpan = (html) => {
  //html to object
  const htmlToObj = html
  const processSpan = (cur, parentStyle = {}) => {
    return cur.children.map(child => {
      if(child.dom !== "#text"){
        return processSpan(child, {...parentStyle, ...cur.style})  
      }else{
        return {
          dom: "span", 
          style: {...parentStyle, ...cur.style}, 
          children: [child]
        }
      }
    })
  }
  return _.flattenDeep(processSpan(htmlToObj))
}

export const renderWordObject = (obj) => {
  const children = obj.children
  return children.map((item, key) => {
    const dom = item.dom
    if(dom === "p"){
      return (
        <p key={key}>
          {renderWordObject(item)}
        </p>
      )
    }else if(dom === "br"){
      return <br key={key}></br>
    }else if(dom === "span"){
      return (
        <span 
          key={key} 
          style={{
            fontSize: `${item.fontSize}px`,
            fontFamily: item.fontFamily,
            fontStyle: item.italic,
            fontWeight: item.bold,
            textDecoration: item.underline
          }}
        >
          {renderWordObject(item)}
        </span>
      )
    }else{
      return item.children
    }
  })
}

const altering = (node, range, setting) => {
  const startEle = range.anchor.path;
  const endEle = range.focus.path;
  // traverse
  node.content.slice(startEle[0], endEle[0] + 1).forEach((p, key) => {
    if (key === 0) {
      // first paragraph
      const shift = splitOffsetPlace(
        p.children,
        range.anchor.path[1],
        range.anchor.offset
      );
      for (let i = range.anchor.path[1] + shift; i < p.children.length; i++) {
        p.children[i] = { ...p.children[i], ...setting };
      }
    } else if (key === endEle[0]) {
      // last paragraph
      splitOffsetPlace(p.children, range.focus.path[1], range.focus.offset);
      for (let i = 0; i < range.focus.path[1] + 1; i++) {
        p.children[i] = { ...p.children[i], ...setting };
      }
    } else {
      for (let i = 0; i < p.children.length; i++) {
        p.children[i] = { ...p.children[i], ...setting };
      }
    }
  });
};

// generated by ChatGPT
const coalescence = (arr) => {
  // refining in one paragraph
  const result = [];
  let currentObj = {};
  for (let i = 0; i < arr.length; i++) {
    const candidate = arr[i];
    if (i === 0) {
      // first one
      currentObj = { ...candidate }; // duplication
    } else if (
      // if properties don't match.
      candidate.dom !== currentObj.dom ||
      candidate.bold !== currentObj.bold ||
      candidate.italic !== currentObj.italic ||
      candidate.underline !== currentObj.underline
    ) {
      // push to result and start a new object
      result.push(currentObj);
      currentObj = { ...candidate };
    } else {
      // Properties match, combine children
      currentObj.children = (currentObj.children || "") + candidate.children;
    }
  }
  result.push(currentObj); // push the last object
  return result;
};

function splitOffsetPlace(arr, target, offset) {
  // direct change on input array
  if (arr[target].children.length !== offset) {
    // check if split is neccessary
    var b4Obj = { ...arr[target] }; // make copy
    b4Obj.children = b4Obj.children.slice(0, offset);
    arr[target].children = arr[target].children.slice(offset);
    arr.splice(target, 0, b4Obj);
    return 1;
  }
  return 0;
}

const htmlToObj = (htmlString) => {
  const html = document.createElement('div')
  html.innerHTML = htmlString
  const nodes = html.childNodes
  const list = [...nodes].map(node => {
    if(node.nodeName === "#text"){
      return {
        dom: node.nodeName,
        children: node.data
      }
    }else{
      const fontSize = node.style.fontSize
      return {
        dom: node.nodeName.toLowerCase(),
        fontSize: Number(fontSize.substring(0, fontSize.length - 2)),
        italic: node.style.fontStyle,
        bold: node.style.fontWeight,
        children: htmlToObj(node.innerHTML)
      }
    }
  })
  return list
}

// the function is generated by ChatGPT
export const setCursorAtPosition = (clientX, clientY) => {
  // Get the contenteditable div, range and selection objects.
  const contentEditableDiv = document.getElementById("editable");
  const range = document.createRange();
  const selection = window.getSelection();
  // Get the document element at the clicked position
  const elementAtPosition = document.elementFromPoint(clientX, clientY)

  // Check if the element is a text node
  if (elementAtPosition.childNodes[0].nodeType === Node.TEXT_NODE) {
    // Get the closest text node
    const textNode = elementAtPosition;
    let caretPos, offset
    if (document.caretPositionFromPoint) {
      caretPos = document.caretPositionFromPoint(clientX, clientY);
      offset = caretPos.offset;
    } else if (document.caretRangeFromPoint) {
      // Use WebKit-proprietary fallback method
      caretPos = document.caretRangeFromPoint(clientX, clientY);
      offset = caretPos.startOffset;
    } else {
      // Neither method is supported, do nothing
      return;
    }
    // Set the range and selection
    range.setStart(textNode.childNodes[0], offset);
    range.collapse(true); // meaning range start and end are the same.
    selection.removeAllRanges(); // remove existing selection
    selection.addRange(range);

    // Set focus to the contenteditable div
    contentEditableDiv.focus();
  }else{
    contentEditableDiv.focus();
    console.log('wrong type')
  }
}